diff --git a/src/crypto/tls/common.go b/src/crypto/tls/common.go
index c68ebfe..091e8a2 100644
--- a/src/crypto/tls/common.go
+++ b/src/crypto/tls/common.go
@@ -307,6 +307,15 @@ type Config struct {
 	// This should be used only for testing.
 	InsecureSkipVerify bool
 
+	// VerifyCertificate returns a verified certificate chain. It will
+	// be called for clients and for servers if the client supplies a
+	// certificate.
+	//
+	// If VerifyCertificate is nil, then Verify from x509.Certificate
+	// will be used. If VerifyCertificate returns an error, then the
+	// connection will be terminated.
+	VerifyCertificate func(certificate *x509.Certificate, opts x509.VerifyOptions) ([][]*x509.Certificate, error)
+
 	// CipherSuites is a list of supported cipher suites. If CipherSuites
 	// is nil, TLS uses a list of suites supported by the implementation.
 	CipherSuites []uint16
diff --git a/src/crypto/tls/handshake_client.go b/src/crypto/tls/handshake_client.go
index 3c996ac..476b8cc 100644
--- a/src/crypto/tls/handshake_client.go
+++ b/src/crypto/tls/handshake_client.go
@@ -275,7 +275,13 @@ func (hs *clientHandshakeState) doFullHandshake() error {
 			}
 			opts.Intermediates.AddCert(cert)
 		}
-		c.verifiedChains, err = certs[0].Verify(opts)
+
+		if c.config.VerifyCertificate != nil {
+			c.verifiedChains, err = c.config.VerifyCertificate(certs[0], opts)
+		} else {
+			c.verifiedChains, err = certs[0].Verify(opts)
+		}
+
 		if err != nil {
 			c.sendAlert(alertBadCertificate)
 			return err
diff --git a/src/crypto/tls/handshake_server.go b/src/crypto/tls/handshake_server.go
index e16cddc..f93a92f 100644
--- a/src/crypto/tls/handshake_server.go
+++ b/src/crypto/tls/handshake_server.go
@@ -681,13 +681,16 @@ func (hs *serverHandshakeState) processCertsFromClient(certificates [][]byte) (c
 			opts.Intermediates.AddCert(cert)
 		}
 
-		chains, err := certs[0].Verify(opts)
+		if c.config.VerifyCertificate != nil {
+			c.verifiedChains, err = c.config.VerifyCertificate(certs[0], opts)
+		} else {
+			c.verifiedChains, err = certs[0].Verify(opts)
+		}
+
 		if err != nil {
 			c.sendAlert(alertBadCertificate)
 			return nil, errors.New("tls: failed to verify client's certificate: " + err.Error())
 		}
-
-		c.verifiedChains = chains
 	}
 
 	if len(certs) > 0 {
diff --git a/src/net/http/transport.go b/src/net/http/transport.go
index 63abd37..49f53c7 100644
--- a/src/net/http/transport.go
+++ b/src/net/http/transport.go
@@ -618,10 +618,14 @@ func (t *Transport) dialConn(cm connectMethod) (*persistConn, error) {
 		closech:    make(chan struct{}),
 		writeErrCh: make(chan error, 1),
 	}
-	tlsDial := t.DialTLS != nil && cm.targetScheme == "https" && cm.proxyURL == nil
+	tlsDial := cm.targetScheme == "https" && cm.proxyURL == nil && (t.DialTLS != nil || (t.TLSClientConfig != nil && t.TLSClientConfig.VerifyCertificate != nil))
 	if tlsDial {
 		var err error
-		pconn.conn, err = t.DialTLS("tcp", cm.addr())
+		if t.DialTLS != nil {
+			pconn.conn, err = t.DialTLS("tcp", cm.addr())
+		} else {
+			pconn.conn, err = tls.Dial("tcp", cm.addr(), t.TLSClientConfig)
+		}
 		if err != nil {
 			return nil, err
 		}
@@ -1510,6 +1514,7 @@ func cloneTLSConfig(cfg *tls.Config) *tls.Config {
 		ClientAuth:               cfg.ClientAuth,
 		ClientCAs:                cfg.ClientCAs,
 		InsecureSkipVerify:       cfg.InsecureSkipVerify,
+		VerifyCertificate:        cfg.VerifyCertificate,
 		CipherSuites:             cfg.CipherSuites,
 		PreferServerCipherSuites: cfg.PreferServerCipherSuites,
 		SessionTicketsDisabled:   cfg.SessionTicketsDisabled,
@@ -1541,6 +1546,7 @@ func cloneTLSClientConfig(cfg *tls.Config) *tls.Config {
 		ClientAuth:               cfg.ClientAuth,
 		ClientCAs:                cfg.ClientCAs,
 		InsecureSkipVerify:       cfg.InsecureSkipVerify,
+		VerifyCertificate:        cfg.VerifyCertificate,
 		CipherSuites:             cfg.CipherSuites,
 		PreferServerCipherSuites: cfg.PreferServerCipherSuites,
 		ClientSessionCache:       cfg.ClientSessionCache,
